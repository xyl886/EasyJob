#!usr/bin/env python
# -*- coding:utf-8 -*-
"""
@author:18034
@file: __init__.py
@time: 2025/04/21
"""
# Core/__init__.py

import importlib
import os
import sys
import threading
import time
import traceback
from concurrent.futures.thread import ThreadPoolExecutor
from pathlib import Path

from Core.Collection import Job, JobStatus, History
from Core.Email import *
from Core.JobBase import JobBase
from Core.MongoDB import MongoDB

_task_executor = ThreadPoolExecutor(max_workers=10)


def get_file_path(current_file, marker=""):
    """
    向上递归查找项目根目录（直到找到标记文件，如 .git/pyproject.toml）
    """
    current_path = Path(current_file).resolve().parent
    while current_path != current_path.parent:  # 防止无限循环
        if (current_path / marker).exists():
            return str(current_path) + "\\" + marker
        current_path = current_path.parent
    raise FileNotFoundError(f"Could not find project root with marker: {marker}")


yaml_path = ''
try:
    yaml_path = get_file_path(__file__, marker="config.yaml")
    print(f"[AutoImport] config.yaml found at: {yaml_path}")
except Exception as e:
    print("[AutoImport] Failed to get_file_path config.yaml, e:" + str(e))
try:
    import yaml

    with open(yaml_path, encoding='utf-8') as f:
        config = yaml.safe_load(f)
    BASE_PACKAGE = config.get('jobs').get('base_package', 'Job')
    MODULE_PATTERN = config.get('jobs').get('module_pattern', 'Action.py')
    DEBUG = config.get('jobs').get('debug')
    MONGO_URI = config.get('mongo').get('uri', 'mongodb://localhost:27017')
    DB_NAME = config.get('mongo').get('database', 'EasyJob')
    SMTP = config.get('smtp')
    TO = config.get('smtp').get('to')
except Exception as e:
    print(f"[AutoImport] Failed to load config.yaml: {e}")
    BASE_PACKAGE = 'Job'
    MODULE_PATTERN = 'Action.py'
    MONGO_URI = 'mongodb://localhost:27017'
    DB_NAME = 'EasyJob'

db = MongoDB(uri=MONGO_URI, db_name=DB_NAME)
Job_c = db['Job']
History_c = db['History']


# ✅ 使用示例
def send_email(title: str, logs: List[dict] = None):
    if logs is None:
        logs = []
    header = sorted({key for log in logs for key in log.keys()})

    # 加载模板
    template_path = get_file_path(__file__, marker="log_template.html")
    with open(template_path, encoding="utf-8") as f:
        template = Template(f.read())

    # 渲染 HTML 内容
    rendered_html = template.render(title=title, logs=logs, header=header)
    email_content = EmailMessageContent(
        to=TO.split(","),
        subject=title,
        body=rendered_html,
        subtype="html"
    )
    smtp_config = SMTPConfig(
        login=SMTP.get('user'),
        password=SMTP.get('password'),
        smtp_server=SMTP.get('host'),
        smtp_port=SMTP.get('port'),
    )
    sender = EmailSender(smtp_config)
    sender.send(email_content)


def run(job_id):
    """
    运行指定任务
    Run specified job

    :param job_id: 任务ID job ID
    :param run_id: 运行ID (默认生成) run ID (auto-generated by default)
    """
    if job_id not in JobBase._registry:
        raise ValueError(f"Job ID {job_id} not registered")
    job_class = JobBase._registry.get(job_id)
    job_instance = job_class(job_id=job_id, run_id=run_id)

    try:
        job_instance.logger.warning("Start JobName: %s   JobID: %s   RunID: %s   StartTime: %s" % (
            job_instance.job_name, job_id, run_id, str(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))))
        try:
            init_job(job_id)
        except Exception as e:
            print(f"Failed to init job: {str(e)}")

        # 提交任务到线程池（非阻塞）
        future = _task_executor.submit(execute_job, job_instance)

        # 添加完成回调（异步记录完成时间）
        future.add_done_callback(
            lambda f: handle_job_completion(f, job_instance)
        )

    except Exception as e:
        job_instance.logger.error(f"Job startup failed: {str(e)}", exc_info=True)
        raise


def init_job(job_id):
    job = Job_c.find_documents(query={"JobId": job_id}, limit=1).dict(0)
    last_history = History_c.find_documents(sort=[("RunId", -1)]).dict(0)
    if last_history:
        run_id = last_history.get("RunId") + 1
    else:
        run_id = 100001
    if not job:
        raise ValueError(f"Job {job_id} not found")
    history = History(
        JobId=job_id,
        JobName=job.get("JobName"),
        Package=job.get("Package"),
        JobClass=job.get("JobClass"),
        Description=job.get("Description"),
        Status=JobStatus.RUNNING,
        RunId=100000,
        Output='',
        StartTime='',
        EndTime='')
    history.RunId = run_id
    history.StartTime = str(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
    history.Status = JobStatus.RUNNING
    History_c.save_dict_to_collection(history.dict(), 'RunId')


def execute_job(job_instance):
    """在独立线程中执行任务逻辑"""
    try:
        # 执行实际任务
        job_instance.on_run()
        return job_instance, None
    except Exception as e:
        return job_instance, e


# 异步回调处理
def handle_job_completion(future, job_instance):
    # 异步发送邮件
    job_id = job_instance.job_id
    run_id = job_instance.run_id

    title = f"{job_instance.job_name}:{job_id}"
    warning_query = {'level': {'$gte': 30}, 'job_id': job_id, 'run_id': run_id}  # 警告级别
    error_query = {'level': {'$gte': 40}, 'job_id': job_id, 'run_id': run_id}  # 错误级别
    history_query = {'JobId': job_id, 'RunId': run_id}  # 历史记录
    histories = History_c.find_documents(query=history_query)
    history = {}
    if histories:
        history = histories[0]

    try:
        job_instance, error = future.result()
        if error:
            raise error
        job_instance.logger.warning("Job finished. JobID: %s  RunID: %s" % (job_id, run_id))
        history['Status'] = JobStatus.COMPLETED
        if not DEBUG:
            if job_instance.db['log'].count(query=error_query) <= 0:
                return
            logs = job_instance.db['log'].find_documents(query=warning_query).dict()
            threading.Thread(target=send_email, args=(title, logs)).start()

    except Exception as e:
        job_instance.logger.error("Job execution failed: JobID: %s  RunID: %s  e: %s" % (job_id, run_id, str(e)),
                                  exc_info=True)
        history['Output'] = f"Job execution failed: {str(e)}"
        history['Status'] = JobStatus.FAILED
    history['EndTime'] = str(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
    History_c.save_dict_to_collection(history, 'RunId')


def auto_import_jobs(base_package=BASE_PACKAGE):
    """
    自动导入所有任务模块
    Automatically import all job modules

    :param base_package: 基础包路径 base package path
    :return: 导入的模块列表 list of imported modules
    """
    base_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), base_package)
    modules = []
    for root, dirs, files in os.walk(base_dir):
        for file in files:
            if file.endswith(MODULE_PATTERN):
                # 构造模块名
                rel_path = os.path.relpath(os.path.join(root, file), os.path.dirname(os.path.dirname(__file__)))
                module_name = rel_path[:-3].replace(os.sep, '.')
                if module_name in sys.modules:
                    continue  # 已导入，跳过
                try:
                    importlib.import_module(module_name)
                    modules.append(module_name)
                except Exception as e:
                    print(f"[AutoImport] Failed to import {module_name}: {e}")
                    traceback.print_exc()
    print(f"[AutoImport] Auto import jobs completed: {modules}")
    print(f"JobBase.registry: {sorted(JobBase._registry.keys())}")


def save_jobs():
    # 保存任务
    existing_job_ids = [job['JobId'] for job in Job_c.find_documents()]
    for job_id, job_class in JobBase._registry.items():
        job_name = str(job_class.__name__)
        try:
            job_dict = Job(
                JobId=job_id,
                JobName=job_name,
                JobClass=str(job_class.__module__),
                Package=BASE_PACKAGE,
                Description=f'This is {job_name}',
                Disabled=1,
                Minute="0",
                Hour="0",
                DayOfWeek="*",
                DayOfMonth="*",
                MonthOfYear="*",
                Status=1
            ).dict()
            if job_id not in existing_job_ids:
                Job_c.save_dict_to_collection(job_dict)
        except Exception as e:
            print(f"[AutoImport] Failed to save job {job_id}: {e}")
            traceback.print_exc()


auto_import_jobs()
__all__ = [
    'BASE_PACKAGE',
    'MODULE_PATTERN',
    'Job_c',
    'History_c',
    'run',
    'get_file_path',
    'auto_import_jobs',
    'save_jobs'
]
